---
name: Atmos Infrastructure Operations

"on":
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: true
        type: choice
        options:
          - plan
          - apply
          - destroy
        default: 'plan'
      component:
        description: 'Component name (e.g., azure-resource-group), "all" for all components, or "affected" for dependency-aware planning'
        required: true
        type: string
      stack:
        description: 'Stack name (e.g., core-eus-dev)'
        required: true
        type: string

jobs:
  plan:
    name: üìã Plan - ${{ inputs.component }} in ${{ inputs.stack }}
    runs-on: ubuntu-latest
    environment: damian_ent_azure
    outputs:
      plan-summary: ${{ steps.plan-summary.outputs.summary }}
      components-list: ${{ steps.components.outputs.components }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install Python dependencies
        run: |
          pip install tabulate

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "~1.9"

      - name: Install Atmos
        run: |
          # Download latest Atmos release directly from GitHub
          ATMOS_VERSION=$(curl -s https://api.github.com/repos/cloudposse/atmos/releases/latest | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
          ATMOS_VERSION_NUM=${ATMOS_VERSION#v}
          echo "Installing Atmos version: $ATMOS_VERSION (numeric: $ATMOS_VERSION_NUM)"
          
          # Debug: Check if variables are properly set
          if [ -z "$ATMOS_VERSION" ]; then
            echo "‚ùå Failed to get Atmos version from GitHub API"
            exit 1
          fi
          
          if [ -z "$ATMOS_VERSION_NUM" ]; then
            echo "‚ùå Failed to extract numeric version"
            exit 1
          fi
          
          # Create temp directory and download
          mkdir -p /tmp/atmos-install
          cd /tmp/atmos-install
          
          # Construct download URL
          DOWNLOAD_URL="https://github.com/cloudposse/atmos/releases/download/${ATMOS_VERSION}/atmos_${ATMOS_VERSION_NUM}_linux_amd64"
          echo "Download URL: $DOWNLOAD_URL"
          
          # Download and install binary directly
          curl -sSfL "$DOWNLOAD_URL" -o atmos
          chmod +x atmos
          sudo mv atmos /usr/local/bin/
          atmos version

      - name: Configure Azure credentials
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          
      - name: Set Terraform ARM environment variables
        run: |
          # Extract credentials from AZURE_CREDENTIALS secret and set ARM_* variables
          echo "Setting ARM environment variables for Terraform..."
          CLIENT_ID=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r .clientId)
          CLIENT_SECRET=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r .clientSecret)
          SUBSCRIPTION_ID=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r .subscriptionId)
          TENANT_ID=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r .tenantId)
          
          # Mask the sensitive values in logs
          echo "::add-mask::$CLIENT_ID"
          echo "::add-mask::$CLIENT_SECRET"
          echo "::add-mask::$SUBSCRIPTION_ID"
          echo "::add-mask::$TENANT_ID"
          
          # Set environment variables
          echo "ARM_CLIENT_ID=$CLIENT_ID" >> $GITHUB_ENV
          echo "ARM_CLIENT_SECRET=$CLIENT_SECRET" >> $GITHUB_ENV
          echo "ARM_SUBSCRIPTION_ID=$SUBSCRIPTION_ID" >> $GITHUB_ENV
          echo "ARM_TENANT_ID=$TENANT_ID" >> $GITHUB_ENV

      - name: Initialize Terraform backend
        run: |
          az storage account show-connection-string \
            --name statomicore \
            --resource-group atmos-rsg-core \
            --output tsv > /dev/null

      - name: Validate inputs
        run: |
          echo "üîç Validating operation inputs..."
          echo "Action: ${{ inputs.action }}"
          echo "Component: ${{ inputs.component }}"
          echo "Stack: ${{ inputs.stack }}"

          # Change to atmos directory where atmos.yaml is located
          cd atmos

          if ! atmos validate stacks; then
            echo "‚ùå Stack configuration validation failed"
            exit 1
          fi

          if [ "${{ inputs.component }}" != "all" ] && [ "${{ inputs.component }}" != "affected" ]; then
            if ! atmos list components -s "${{ inputs.stack }}" | \
              grep -q "^${{ inputs.component }}$"; then
              echo "‚ùå Component ${{ inputs.component }} not found in stack ${{ inputs.stack }}"
              exit 1
            fi
          fi

      - name: Get components list
        id: components
        run: |
          # Change to atmos directory
          cd atmos
          
          if [ "${{ inputs.component }}" = "all" ]; then
            echo "üîç Getting all components for stack ${{ inputs.stack }}..."
            COMPONENTS=$(atmos list components -s "${{ inputs.stack }}" | grep -v "^$" | sort)
            echo "components<<EOF" >> $GITHUB_OUTPUT
            echo "$COMPONENTS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "Found components:"
            echo "$COMPONENTS"
          elif [ "${{ inputs.component }}" = "affected" ]; then
            echo "üîç Using dependency-aware planning for affected components..."
            echo "components=affected" >> $GITHUB_OUTPUT
            echo "Will use atmos terraform plan --affected for dependency-aware planning"
          else
            echo "components=${{ inputs.component }}" >> $GITHUB_OUTPUT
            echo "Single component: ${{ inputs.component }}"
          fi

      - name: Run Terraform Plans
        id: run-plans
        timeout-minutes: 15
        run: |
          echo "üìã Running Terraform plans..."
          mkdir -p /tmp/plans
          cd atmos
          
          if [ "${{ steps.components.outputs.components }}" = "affected" ]; then
            echo "üìã Planning affected components in dependency order..."
            PLAN_FILE="/tmp/plans/affected.plan"
            
            # Use Atmos dependency-aware planning
            timeout 900 atmos terraform plan --affected -s "${{ inputs.stack }}" \
              -no-color -input=false > "$PLAN_FILE" 2>&1 && PLAN_STATUS=$? || PLAN_STATUS=$?
            
            if [ $PLAN_STATUS -eq 0 ]; then
              echo "‚úÖ Affected components planned successfully"
            elif [ $PLAN_STATUS -eq 124 ]; then
              echo "‚è∞ Affected planning timed out (15 minutes)"
              echo "Affected components planning timed out after 15 minutes" >> "$PLAN_FILE"
              exit 1
            else
              echo "‚ùå Affected planning failed"
              echo "Last 50 lines of output:"
              tail -50 "$PLAN_FILE"
              exit 1
            fi
          else
            echo "${{ steps.components.outputs.components }}" | while read -r component; do
              if [ -n "$component" ]; then
                echo "üìã Planning component: $component (timeout: 10 minutes)"
                PLAN_FILE="/tmp/plans/$component.plan"
                
                # Set timeout for individual component planning
                timeout 600 atmos terraform plan "$component" -s "${{ inputs.stack }}" \
                  -no-color -input=false > "$PLAN_FILE" 2>&1 && PLAN_STATUS=$? || PLAN_STATUS=$?
                
                if [ $PLAN_STATUS -eq 0 ]; then
                  echo "‚úÖ Plan completed for component: $component"
                elif [ $PLAN_STATUS -eq 124 ]; then
                  echo "‚è∞ Plan timed out for component: $component (10 minutes)"
                  echo "Component $component timed out after 10 minutes" >> "$PLAN_FILE"
                  exit 1
                else
                  echo "‚ùå Plan failed for component: $component"
                  echo "Last 50 lines of output:"
                  tail -50 "$PLAN_FILE"
                  exit 1
                fi
              fi
            done
          fi

      - name: Generate Plan Dashboard
        id: plan-summary
        run: |
          echo "üé® Generating plan dashboard..."
          
          # Create a combined dashboard for all components
          python3 - << 'EOF'
          import sys
          import os
          import glob
          from pathlib import Path
          
          # Add the scripts directory to the Python path
          sys.path.insert(0, 'scripts')
          
          # Import the dashboard generator module
          import parse_terraform_plan
          
          # Read all plan files
          component_plans = {}
          for plan_file in glob.glob('/tmp/plans/*.plan'):
              component = Path(plan_file).stem
              with open(plan_file, 'r') as f:
                  component_plans[component] = f.read()
          
          # Generate dashboard
          if component_plans:
              dashboard = parse_terraform_plan.generate_dashboard(component_plans)
              
              # Save to file and output
              with open('/tmp/plan-dashboard.md', 'w') as f:
                  f.write(dashboard)
              
              # Output for job summary (truncated if too long)
              if len(dashboard) > 50000:
                  summary = dashboard[:50000] + "\n\n... (truncated, see artifacts for full dashboard)"
              else:
                  summary = dashboard
              
              # Write to step summary
              with open(os.environ['GITHUB_STEP_SUMMARY'], 'w') as f:
                  f.write(summary)
              
              print("Dashboard generated successfully!")
          else:
              print("No plans found to process")
          EOF

      - name: Upload Plan Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plans-${{ inputs.stack }}-${{ inputs.component }}
          path: |
            /tmp/plans/
            /tmp/plan-dashboard.md
          retention-days: 30

  apply-destroy:
    name: üöÄ ${{ inputs.action }} - ${{ inputs.component }} in ${{ inputs.stack }}
    runs-on: ubuntu-latest
    environment: damian_ent_azure
    needs: plan
    if: inputs.action != 'plan'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "~1.9"

      - name: Install Atmos
        run: |
          # Download latest Atmos release directly from GitHub
          ATMOS_VERSION=$(curl -s https://api.github.com/repos/cloudposse/atmos/releases/latest | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
          ATMOS_VERSION_NUM=${ATMOS_VERSION#v}
          echo "Installing Atmos version: $ATMOS_VERSION (numeric: $ATMOS_VERSION_NUM)"
          
          # Debug: Check if variables are properly set
          if [ -z "$ATMOS_VERSION" ]; then
            echo "‚ùå Failed to get Atmos version from GitHub API"
            exit 1
          fi
          
          if [ -z "$ATMOS_VERSION_NUM" ]; then
            echo "‚ùå Failed to extract numeric version"
            exit 1
          fi
          
          # Create temp directory and download
          mkdir -p /tmp/atmos-install
          cd /tmp/atmos-install
          
          # Construct download URL
          DOWNLOAD_URL="https://github.com/cloudposse/atmos/releases/download/${ATMOS_VERSION}/atmos_${ATMOS_VERSION_NUM}_linux_amd64"
          echo "Download URL: $DOWNLOAD_URL"
          
          # Download and install binary directly
          curl -sSfL "$DOWNLOAD_URL" -o atmos
          chmod +x atmos
          sudo mv atmos /usr/local/bin/
          atmos version

      - name: Configure Azure credentials
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          
      - name: Set Terraform ARM environment variables
        run: |
          # Extract credentials from AZURE_CREDENTIALS secret and set ARM_* variables
          echo "Setting ARM environment variables for Terraform..."
          CLIENT_ID=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r .clientId)
          CLIENT_SECRET=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r .clientSecret)
          SUBSCRIPTION_ID=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r .subscriptionId)
          TENANT_ID=$(echo '${{ secrets.AZURE_CREDENTIALS }}' | jq -r .tenantId)
          
          # Mask the sensitive values in logs
          echo "::add-mask::$CLIENT_ID"
          echo "::add-mask::$CLIENT_SECRET"
          echo "::add-mask::$SUBSCRIPTION_ID"
          echo "::add-mask::$TENANT_ID"
          
          # Set environment variables
          echo "ARM_CLIENT_ID=$CLIENT_ID" >> $GITHUB_ENV
          echo "ARM_CLIENT_SECRET=$CLIENT_SECRET" >> $GITHUB_ENV
          echo "ARM_SUBSCRIPTION_ID=$SUBSCRIPTION_ID" >> $GITHUB_ENV
          echo "ARM_TENANT_ID=$TENANT_ID" >> $GITHUB_ENV

      - name: Initialize Terraform backend
        run: |
          az storage account show-connection-string \
            --name statomicore \
            --resource-group atmos-rsg-core \
            --output tsv > /dev/null

      - name: Manual Approval Required
        uses: trstringer/manual-approval@v1
        with:
          secret: ${{ github.TOKEN }}
          approvers: ${{ github.actor }}
          minimum-approvals: 1
          issue-title: "Manual Approval: ${{ inputs.action }} ${{ inputs.component }} in ${{ inputs.stack }}"
          issue-body: |
            ## üö® Manual Approval Required
            
            **Action**: ${{ inputs.action }}
            **Component**: ${{ inputs.component }}
            **Stack**: ${{ inputs.stack }}
            **Triggered by**: @${{ github.actor }}
            
            ### üìã Plan Summary
            Please review the plan summary from the previous job before approving.
            
            **‚ö†Ô∏è Warning**: This action will modify your infrastructure!
            
            ### üîç How to Review
            1. Check the plan dashboard in the previous job's summary
            2. Review the uploaded plan artifacts
            3. Ensure the changes are expected
            
            ### ‚úÖ Approval
            Comment with `/approve` to proceed or `/deny` to cancel.

      - name: Run Terraform Apply
        if: inputs.action == 'apply'
        run: |
          cd atmos
          echo "üöÄ Running Terraform apply in ${{ inputs.stack }}..."
          
          if [ "${{ inputs.component }}" = "all" ]; then
            echo "üöÄ Deploying all components with dependency handling..."
            # Use atmos terraform deploy for proper dependency order
            if ! atmos terraform deploy --all -s "${{ inputs.stack }}" --deploy-run-init; then
              echo "‚ùå Deploy failed for stack: ${{ inputs.stack }}"
              exit 1
            fi
            echo "‚úÖ Deploy completed for all components in stack: ${{ inputs.stack }}"
          elif [ "${{ inputs.component }}" = "affected" ]; then
            echo "üöÄ Deploying affected components in dependency order..."
            if ! atmos terraform deploy --affected -s "${{ inputs.stack }}" --deploy-run-init; then
              echo "‚ùå Deploy failed for affected components in stack: ${{ inputs.stack }}"
              exit 1
            fi
            echo "‚úÖ Deploy completed for affected components in stack: ${{ inputs.stack }}"
          else
            echo "üöÄ Applying single component: ${{ inputs.component }}"
            if ! atmos terraform apply "${{ inputs.component }}" \
              -s "${{ inputs.stack }}" -auto-approve; then
              echo "‚ùå Apply failed for component: ${{ inputs.component }}"
              exit 1
            fi
            echo "‚úÖ Apply completed for component: ${{ inputs.component }}"
          fi

      - name: Run Terraform Destroy
        if: inputs.action == 'destroy'
        run: |
          cd atmos
          echo "üî• Running Terraform destroy in ${{ inputs.stack }}..."
          
          if [ "${{ inputs.component }}" = "all" ] || [ "${{ inputs.component }}" = "affected" ]; then
            echo "üî• Destroying all components in reverse dependency order..."
            # For destroy, we need to reverse the dependency order
            # Destroy private endpoints first, then dependent services, then base infrastructure
            DESTROY_ORDER="azure-private-endpoint-keyvault azure-private-endpoint-datalake-dfs azure-private-endpoint-datalake-blob azure-private-endpoint-storage-blob azure-keyvault-secure azure-keyvault-dev azure-storage-account-datalake azure-storage-account-private azure-storage-account-general azure-nsg azure-subnet azure-vnet azure-resource-group"
            
            for component in $DESTROY_ORDER; do
              if echo "${{ needs.plan.outputs.components-list }}" | grep -q "$component"; then
                echo "üî• Destroying component: $component"
                if ! atmos terraform destroy "$component" \
                  -s "${{ inputs.stack }}" -auto-approve; then
                  echo "‚ùå Destroy failed for component: $component"
                  exit 1
                fi
                echo "‚úÖ Destroy completed for component: $component"
              fi
            done
          else
            echo "üî• Destroying single component: ${{ inputs.component }}"
            if ! atmos terraform destroy "${{ inputs.component }}" \
              -s "${{ inputs.stack }}" -auto-approve; then
              echo "‚ùå Destroy failed for component: ${{ inputs.component }}"
              exit 1
            fi
            echo "‚úÖ Destroy completed for component: ${{ inputs.component }}"
          fi

      - name: Upload Operation Logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: >
            terraform-logs-${{ inputs.action }}-${{ inputs.component }}-${{
            inputs.stack }}
          path: |
            ~/.atmos/logs/
            /tmp/terraform-*.log
          retention-days: 30
